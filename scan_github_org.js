#!/usr/bin/env node
/**
 * Git GitHub Organization Scanner
 *
 * Scans the nstarx GitHub organization for repositories and collects statistics
 * including human vs AI-generated code metrics.
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const ORG_NAME = 'nstarx';
const GITHUB_API = 'https://api.github.com';

// Patterns to detect AI-generated commits
const AI_PATTERNS = {
  claude: [
    /claude/i,
    /anthropic/i,
    /generated with claude/i,
    /co-authored-by:.*claude/i,
    /\ud83e\udd16.*claude/i,
  ],
  copilot: [
    /copilot/i,
    /co-authored-by:.*copilot/i,
    /github copilot/i,
  ],
  gpt: [
    /chatgpt/i,
    /openai/i,
    /gpt-4/i,
    /gpt-3/i,
    /generated by gpt/i,
  ],
  cursor: [
    /cursor/i,
    /generated with cursor/i,
  ],
  generic: [
    /ai-generated/i,
    /auto-generated/i,
    /generated by ai/i,
    /\ud83e\udd16/,
  ]
};

function detectAICommit(commitMessage, authorName, authorEmail) {
  const textToCheck = `${commitMessage} ${authorName} ${authorEmail}`.toLowerCase();

  for (const [aiType, patterns] of Object.entries(AI_PATTERNS)) {
    for (const pattern of patterns) {
      if (pattern.test(textToCheck)) {
        return { isAI: true, aiType };
      }
    }
  }

  // Check for bot emails
  if (authorEmail && (
    authorEmail.includes('bot@') ||
    authorEmail.includes('noreply@anthropic') ||
    authorEmail.includes('copilot') ||
    authorEmail.includes('[bot]')
  )) {
    return { isAI: true, aiType: 'bot' };
  }

  return { isAI: false, aiType: null };
}

async function fetchWithAuth(url) {
  const headers = {
    'Accept': 'application/vnd.github.v3+json',
    'User-Agent': 'git-scan-cli'
  };

  if (process.env.GITHUB_TOKEN) {
    headers['Authorization'] = `token ${process.env.GITHUB_TOKEN}`;
  }

  const response = await fetch(url, { headers });

  if (!response.ok) {
    throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
  }

  return response.json();
}

async function fetchWithHeaders(url) {
  const headers = {
    'Accept': 'application/vnd.github.v3+json',
    'User-Agent': 'git-scan-cli'
  };

  if (process.env.GITHUB_TOKEN) {
    headers['Authorization'] = `token ${process.env.GITHUB_TOKEN}`;
  }

  const response = await fetch(url, { headers });
  return response;
}

async function getOrgRepos(orgName) {
  const repos = [];
  let page = 1;
  const perPage = 100;

  while (true) {
    const url = `${GITHUB_API}/orgs/${orgName}/repos?per_page=${perPage}&page=${page}&sort=updated`;
    const data = await fetchWithAuth(url);

    if (data.length === 0) break;

    repos.push(...data);

    if (data.length < perPage) break;
    page++;
  }

  return repos;
}

async function getRepoContributors(orgName, repoName) {
  try {
    const url = `${GITHUB_API}/repos/${orgName}/${repoName}/contributors?per_page=100`;
    const data = await fetchWithAuth(url);
    return Array.isArray(data) ? data : [];
  } catch {
    return [];
  }
}

async function getRepoBranches(orgName, repoName) {
  try {
    const url = `${GITHUB_API}/repos/${orgName}/${repoName}/branches?per_page=100`;
    const data = await fetchWithAuth(url);
    return Array.isArray(data) ? data.length : 0;
  } catch {
    return 0;
  }
}

async function getRepoCommitCount(orgName, repoName) {
  try {
    const url = `${GITHUB_API}/repos/${orgName}/${repoName}/commits?per_page=1`;
    const response = await fetchWithHeaders(url);

    const linkHeader = response.headers.get('Link');
    if (linkHeader) {
      const match = linkHeader.match(/page=(\d+)>; rel="last"/);
      if (match) {
        return parseInt(match[1], 10);
      }
    }

    const data = await response.json();
    return Array.isArray(data) ? data.length : 0;
  } catch {
    return 0;
  }
}

async function getCommitStats(orgName, repoName, days = 365) {
  const stats = {
    calendar: {},
    human_calendar: {},
    ai_calendar: {},
    total_commits: 0,
    human_commits: 0,
    ai_commits: 0,
    ai_breakdown: {
      claude: 0,
      copilot: 0,
      gpt: 0,
      cursor: 0,
      generic: 0,
      bot: 0
    },
    recent_commits: [],
    contributors_human: new Set(),
    contributors_ai: new Set()
  };

  const since = new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString();

  try {
    let page = 1;
    const perPage = 100;

    while (page <= 10) {
      const url = `${GITHUB_API}/repos/${orgName}/${repoName}/commits?per_page=${perPage}&page=${page}&since=${since}`;
      const data = await fetchWithAuth(url);

      if (!Array.isArray(data) || data.length === 0) break;

      for (const commit of data) {
        const date = commit.commit?.author?.date?.split('T')[0];
        const message = commit.commit?.message || '';
        const authorName = commit.commit?.author?.name || '';
        const authorEmail = commit.commit?.author?.email || '';

        if (!date) continue;

        stats.total_commits++;
        stats.calendar[date] = (stats.calendar[date] || 0) + 1;

        const { isAI, aiType } = detectAICommit(message, authorName, authorEmail);

        if (isAI) {
          stats.ai_commits++;
          stats.ai_calendar[date] = (stats.ai_calendar[date] || 0) + 1;
          if (aiType) stats.ai_breakdown[aiType]++;
          stats.contributors_ai.add(authorEmail || authorName);
        } else {
          stats.human_commits++;
          stats.human_calendar[date] = (stats.human_calendar[date] || 0) + 1;
          stats.contributors_human.add(authorEmail || authorName);
        }

        // Keep last 10 commits for display
        if (stats.recent_commits.length < 10) {
          stats.recent_commits.push({
            sha: commit.sha?.substring(0, 7),
            message: message.split('\n')[0].substring(0, 80),
            author: authorName,
            date: date,
            isAI,
            aiType,
            url: commit.html_url
          });
        }
      }

      if (data.length < perPage) break;
      page++;
    }
  } catch {
    // Return partial stats on error
  }

  // Convert Sets to counts
  stats.contributors_human = stats.contributors_human.size;
  stats.contributors_ai = stats.contributors_ai.size;

  return stats;
}

async function checkClaudeConfig(orgName, repoName) {
  const result = {
    has_claude_folder: false,
    has_claude_md: false,
    claude_settings: null
  };

  try {
    const claudeFolderUrl = `${GITHUB_API}/repos/${orgName}/${repoName}/contents/.claude`;
    const folderResponse = await fetchWithHeaders(claudeFolderUrl);
    result.has_claude_folder = folderResponse.ok;

    if (folderResponse.ok) {
      const folderData = await folderResponse.json();
      if (Array.isArray(folderData)) {
        result.claude_settings = folderData.map(f => f.name);
      }
    }
  } catch {
    // Folder doesn't exist
  }

  try {
    const claudeMdUrl = `${GITHUB_API}/repos/${orgName}/${repoName}/contents/CLAUDE.md`;
    const mdResponse = await fetchWithHeaders(claudeMdUrl);
    result.has_claude_md = mdResponse.ok;
  } catch {
    // File doesn't exist
  }

  return result;
}

function formatSize(bytes) {
  const units = ['B', 'KB', 'MB', 'GB'];
  let size = bytes;
  let unitIndex = 0;

  while (size >= 1024 && unitIndex < units.length - 1) {
    size /= 1024;
    unitIndex++;
  }

  return `${size.toFixed(1)} ${units[unitIndex]}`;
}

function calculatePopularityScore(stats) {
  let score = 0;
  const breakdown = {};

  // Stars (up to 100 points, 2 per star)
  const starPoints = Math.min(stats.stars * 2, 100);
  score += starPoints;
  breakdown.stars = starPoints;

  // Forks (up to 50 points, 5 per fork)
  const forkPoints = Math.min(stats.forks * 5, 50);
  score += forkPoints;
  breakdown.forks = forkPoints;

  // Commit count (up to 100 points, 1 per 10 commits)
  const commitPoints = Math.min(stats.commit_count / 10, 100);
  score += commitPoints;
  breakdown.commits = Math.round(commitPoints * 100) / 100;

  // Recent activity (up to 50 points)
  let activityPoints = 0;
  if (stats.last_commit_date) {
    const lastCommit = new Date(stats.last_commit_date);
    const daysSince = Math.floor((Date.now() - lastCommit.getTime()) / (1000 * 60 * 60 * 24));

    if (daysSince < 7) activityPoints = 50;
    else if (daysSince < 30) activityPoints = 40;
    else if (daysSince < 90) activityPoints = 25;
    else if (daysSince < 365) activityPoints = 10;
  }
  score += activityPoints;
  breakdown.activity = activityPoints;

  // Contributors (up to 30 points, 5 per contributor)
  const contribPoints = Math.min(stats.contributor_count * 5, 30);
  score += contribPoints;
  breakdown.contributors = contribPoints;

  // Watchers (up to 20 points, 2 per watcher)
  const watcherPoints = Math.min(stats.watchers * 2, 20);
  score += watcherPoints;
  breakdown.watchers = watcherPoints;

  return {
    total: Math.round(score * 100) / 100,
    breakdown,
    max_possible: 350
  };
}

function classifyProject(stats) {
  const aiRatio = stats.commit_stats.total_commits > 0
    ? stats.commit_stats.ai_commits / stats.commit_stats.total_commits
    : 0;

  const hasClaude = stats.has_claude_folder || stats.has_claude_md;

  if (hasClaude && aiRatio >= 0.5) {
    return 'ai-heavy';
  } else if (hasClaude || aiRatio >= 0.2) {
    return 'ai-assisted';
  } else if (aiRatio > 0) {
    return 'mixed';
  } else {
    return 'human';
  }
}

async function scanOrganization(orgName) {
  console.log(`Scanning GitHub organization: ${orgName}...`);

  const repos = await getOrgRepos(orgName);
  console.log(`Found ${repos.length} repositories`);

  const projects = [];
  const orgStats = {
    total_commits: 0,
    human_commits: 0,
    ai_commits: 0,
    ai_breakdown: { claude: 0, copilot: 0, gpt: 0, cursor: 0, generic: 0, bot: 0 },
    projects_by_type: { human: 0, mixed: 0, 'ai-assisted': 0, 'ai-heavy': 0 }
  };

  for (const repo of repos) {
    console.log(`  Processing: ${repo.name}`);

    const [contributors, branchCount, commitCount, commitStats, claudeConfig] = await Promise.all([
      getRepoContributors(orgName, repo.name),
      getRepoBranches(orgName, repo.name),
      getRepoCommitCount(orgName, repo.name),
      getCommitStats(orgName, repo.name),
      checkClaudeConfig(orgName, repo.name)
    ]);

    const stats = {
      name: repo.name,
      full_name: repo.full_name,
      url: repo.html_url,
      description: repo.description || 'No description available',
      has_claude_folder: claudeConfig.has_claude_folder,
      has_claude_md: claudeConfig.has_claude_md,
      claude_settings: claudeConfig.claude_settings,
      size_bytes: repo.size * 1024,
      size_human: formatSize(repo.size * 1024),
      stars: repo.stargazers_count,
      forks: repo.forks_count,
      watchers: repo.watchers_count,
      open_issues: repo.open_issues_count,
      commit_count: commitCount,
      branch_count: branchCount,
      contributor_count: Array.isArray(contributors) ? contributors.length : 0,
      contributors: Array.isArray(contributors) ? contributors.slice(0, 10).map(c => ({
        login: c.login,
        avatar: c.avatar_url,
        contributions: c.contributions,
        url: c.html_url
      })) : [],
      primary_language: repo.language || 'Unknown',
      topics: repo.topics || [],
      created_at: repo.created_at,
      first_commit_date: repo.created_at,
      last_commit_date: repo.pushed_at,
      is_fork: repo.fork,
      is_archived: repo.archived,
      default_branch: repo.default_branch,
      license: repo.license?.spdx_id || null,
      commit_stats: commitStats
    };

    const scoreData = calculatePopularityScore(stats);
    stats.popularity_score = scoreData.total;
    stats.score_breakdown = scoreData.breakdown;
    stats.score_max = scoreData.max_possible;

    stats.project_type = classifyProject(stats);

    // Aggregate org stats
    orgStats.total_commits += commitStats.total_commits;
    orgStats.human_commits += commitStats.human_commits;
    orgStats.ai_commits += commitStats.ai_commits;
    for (const [key, val] of Object.entries(commitStats.ai_breakdown)) {
      orgStats.ai_breakdown[key] += val;
    }
    orgStats.projects_by_type[stats.project_type]++;

    projects.push(stats);
  }

  projects.sort((a, b) => b.popularity_score - a.popularity_score);

  return { projects, orgStats };
}

async function main() {
  try {
    const { projects, orgStats } = await scanOrganization(ORG_NAME);

    const output = {
      generated_at: new Date().toISOString(),
      organization: ORG_NAME,
      organization_url: `https://github.com/${ORG_NAME}`,
      total_projects: projects.length,
      org_stats: orgStats,
      score_legend: {
        description: 'Popularity score based on repository activity and engagement',
        max_score: 350,
        components: {
          stars: { max: 100, formula: '2 points per star (max 100)' },
          forks: { max: 50, formula: '5 points per fork (max 50)' },
          commits: { max: 100, formula: '1 point per 10 commits (max 100)' },
          activity: { max: 50, formula: '50 pts (<7 days), 40 (<30), 25 (<90), 10 (<365)' },
          contributors: { max: 30, formula: '5 points per contributor (max 30)' },
          watchers: { max: 20, formula: '2 points per watcher (max 20)' }
        }
      },
      project_types: {
        'human': 'No AI-generated commits detected',
        'mixed': 'Less than 20% AI-generated commits',
        'ai-assisted': 'Has Claude config OR 20-50% AI commits',
        'ai-heavy': 'Has Claude config AND 50%+ AI commits'
      },
      projects
    };

    const outputPath = path.join(__dirname, 'projects.json');
    fs.writeFileSync(outputPath, JSON.stringify(output, null, 2), 'utf-8');

    console.log(`\nFound ${projects.length} repositories`);
    console.log(`Output saved to: ${outputPath}`);

    // Print summary
    console.log('\n' + '='.repeat(60));
    console.log('ORGANIZATION SUMMARY');
    console.log('='.repeat(60));
    console.log(`Total commits analyzed: ${orgStats.total_commits}`);
    console.log(`Human commits: ${orgStats.human_commits} (${((orgStats.human_commits/orgStats.total_commits)*100).toFixed(1)}%)`);
    console.log(`AI commits: ${orgStats.ai_commits} (${((orgStats.ai_commits/orgStats.total_commits)*100).toFixed(1)}%)`);
    console.log(`\nProjects by type:`);
    for (const [type, count] of Object.entries(orgStats.projects_by_type)) {
      console.log(`  ${type}: ${count}`);
    }

    if (projects.length > 0) {
      console.log('\n' + '='.repeat(60));
      console.log('TOP 10 REPOSITORIES (by popularity score)');
      console.log('='.repeat(60));

      for (let i = 0; i < Math.min(10, projects.length); i++) {
        const p = projects[i];
        const aiPct = p.commit_stats.total_commits > 0
          ? ((p.commit_stats.ai_commits / p.commit_stats.total_commits) * 100).toFixed(1)
          : '0';
        console.log(`\n${i + 1}. ${p.name} [${p.project_type}]`);
        console.log(`   Score: ${p.popularity_score}/${p.score_max} | Language: ${p.primary_language}`);
        console.log(`   Stars: ${p.stars} | Forks: ${p.forks} | Commits: ${p.commit_count}`);
        console.log(`   Human: ${p.commit_stats.human_commits} | AI: ${p.commit_stats.ai_commits} (${aiPct}%)`);
        if (p.has_claude_folder || p.has_claude_md) {
          console.log(`   Claude: ${p.has_claude_folder ? '.claude/' : ''} ${p.has_claude_md ? 'CLAUDE.md' : ''}`);
        }
      }
    }
  } catch (error) {
    console.error('Error:', error.message);
    process.exit(1);
  }
}

main();
